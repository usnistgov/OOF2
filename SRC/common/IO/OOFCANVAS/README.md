This software was produced by NIST, an agency of the U.S. government,
and by statute is not subject to copyright in the United
States. Recipients of this software assume all responsibilities
associated with its operation, modification and maintenance. However,
to facilitate maintenance we ask that before distributing modified
versions of this software, you first contact the authors at
oof_manager@nist.gov.

---


# OOFCanvas summary

OOFCanvas is a replacement for libgnomecanvas, designed for use in
OOF2, but hopefully useful elsewhere. OOFCanvas is based on
[Cairo](https://www.cairographics.org/) and is compatible with gtk3.
It might eventually also be compatible with gtk+2.

OOF2 uses [libgnomecanvas](https://developer.gnome.org/libgnomecanvas/)
to display and interact with images and meshes.  But libgnomecanvas
requires gtk+2, and gtk+2 works only with python3, not python2, and
python2 is being phased out.  In order to upgrade OOF2 to python3, we
need to first upgrade it from gtk+2 to gtk+3, and to do that we need
to first replace libgnomecanvas.

The canvas is a drawing area that can display a variety of shapes,
including text. It can be scrolled, zoomed, and printed.  Items drawn
on the canvas can be selected with the mouse.

OOFCanvas is *not* a drop-in replacement for libgnomecanvas.  It's
also not a full-fledged gtk widget.  It's a set of classes that does
some of what libgnomecanvas did and uses gtk.

All of the code is in C++.  Wrappers for Python 2.7 have been
generated by an old version of SWIG.  Hopefully we've remembered to
distribute the SWIG output so that users don't need to run SWIG
themselves.

All the classes and functions described here are defined in the C++
`OOFCanvas` namespace.  For simplicity we haven't included it
explicitly in the discussion below. 

### Coordinate Systems

There are two important coordinates systems: user coordinates and
pixel coordinates.

*Pixel* coordinates measure distance in pixels, with x increasing from
left to right and y increasing from top to bottom.  The origin is at
the upper left corner of the Canvas, which may or may not be visible
on the screen.

Objects drawn on the canvas are specified in *user* coordinates, which
may be anything convenient to the user.  x goes from left to right on
the screen, and **y goes from bottom to top**.  This is not the
convention in many graphics libraries, but is standard in the real
world.

The conversion from user to pixel coordinates depends on the size
of the canvas and the current zoom factor, and determines the ppu
(pixels per unit).  Almost all objects in OOFCanvas are specified in
user coordinates, so the user does not need to worry about the pixel
coordinate system at all.  The one exception is that the *sizes* of
some objects can be specified in pixels.


## The Canvas Classes

Three kinds of Canvas objects are defined.

* `OffScreenCanvas is` the base class.  It can be used to make drawings
that will be printed or saved to a file, but not displayed.

* `Canvas `is derived from `OOFScreenCanvas` (via an intermediate abstract
`GUICanvasBase` class).  It creates a `Gtk.Layout` which can be used in
Gtk3 to put the `Canvas` in a GUI.  It calls user-provided callback
functions in response to mouse events.

* A slightly different Canvas class is available in Python.  It's
actually a C++ class called `PythonCanvas`, which is derived from
`GUICanvasBase` and renamed to `Canvas` when exported to Python.  The main
difference between the C++ and Python `Canvas` classes is that the
Python class expects callback functions to be Python methods, and the
`GtkLayout` is created in Python.

The pixel size of a `Canvas` or `PythonCanvas` is determined by the Gtk
window that it's part of.  The pixel size of an `OffScreenCanvas` is
only computed when it's saved as an image and the size of the image is
given.

## The CanvasLayer Class

Drawing is done by creating one or more `CanvasLayers` and adding
`CanvasItems` to them.  `CanvasLayers` can be shown, hidden, and
reordered, making it easy to change what's visible on the canvas.
Opaque items in higher layers obscure the items in lower layers.

`CanvasLayers` are created by calling `OffScreenCanvas::newLayer()` and
destroyed by calling either `CanvasLayer::destroy()` or
`OffScreenCanvas::deleteLayer()`.

The size of a layer in pixels is determined by the sizes (in user
coordinates) of the items being displayed, and the current `ppu`.

## The CanvasItem Classes

Everything drawn on a `Canvas` is an instance of a `CanvasItem` subclass.
Pointers to `CanvasItem`s are passed to `CanvasLayer::addItem`.  The
`CanvasLayer` will destroy its `CanvasItem`s when appropriate -- the user
should never destroy them explicitly. 

Each `CanvasItem` has a bunch of parameters that determine its position,
shape, color, and transparency.  Position parameters are always given
in user coordinates.  Some parameters, such as line widths, can be
given in either user or pixel units.

Details of each `CanvasItem` subclass are given [somewhere
below](#canvasitems).

## Basic Usage

In C++

```C++
double ppu; // pixels per unit -- initialize to something sensible
// Create a Canvas
Canvas canvas(ppu);
// Get a pointer to the GtkLayout widget
GtkWidget *widget = canvas.gtk(); 

// Install the canvas in the gui.  For example, if it's going into
// a GtkFrame,
frame.add(widget)

// Create a canvas layer
CanvasLayer *layer = canvas.newLayer("layername");

// Add items to the layer
double x=1., y=2., radius=1.4;  
CanvasCircle *circle = new CanvasCircle(x, y, radius); // In user coordinates.
circle->setLineWidthInPixels(1.5); // In pixel units
Color red(1., 0., 0., 0.5); // r, g, b, a, all in [0.0, 1.0]
circle.setFillColor(red);
layer->addItem(circle);

// Add more items if you want
...

// Draw the items to the canvas
canvas.draw();
```

The equivalent Python is virtually identical

```python
from OOFCANVAS import oofcanvas, oofcanvasgui
canvas = oofcanvasgui.Canvas(width=300, height=300, ppu=1.0,
                             vexpand=True, hexpand=True)
frame.add(canvas.layout)

layer = oofcanvas.CanvasLayer()

x = 1.
y = 2.
radius = 1.4
circle = CanvasCircle(x, y, radius)
circle.setLineWidthInPixels(1.5)
red = oofcanvas.Color(1., 0, 0, 0.5)
circle.setFillColor(red)
layer.addItem(circle)

canvas.draw()
```

Calling `Canvas::draw` doesn't actually draw anything.  Instead, it
generates a Gtk event that causes `GUICanvasBase::drawHandler` to be
called from the Gtk main loop.

## Mouse 

The Canvas's `setMouseCallback` method installs a mouse event handler,
which will be called whenever a mouse button is pressed or released,
the mouse is moved, or the scroll wheel is turned.


Call `GUICanvasBase::setMouseCallback(MouseCallback callback, void
*data)` to install a mouse event handler.  `callback` will be called
whenever a mouse button is pressed, the mouse is moved, or the window
is scrolled. 

To install a rubberband that will be displayed when the mouse is
moving, call `GUICanvasBase::setRubberBand(RubberBand*)` from the
callback for the mouse-down event.  The various types of `RubberBand`
and details of how to use them are described in the section on the
`RubberBand` class, below.  To stop displaying the `RubberBand`, pass
a null pointer (in C++) or `None` in (in Python) to `setRubberBand()`.

The current position of the mouse
will be passed to the rubberband's `draw()` method whenever the mouse
is moved.  Various kinds of rubberbands are defined in `rubberband.h`.
To stop displaying the rubberband, pass `nullptr` (in C++) or `None`
(in Python) to `setRubberBand()`.  OOFCanvas does *not* take ownership
of the rubberband object.  The calling code must delete it when done
with it in C++ (if necessary) and make sure to retain a reference to
it in Python (when necessary).


OOFCanvas does not handle selection of objects with the mouse, but it
does provide the position of a mouse click as part of the data passed
to the callback function.  Additionally, it is possible to get a list
of all `CanvasItems` at a point with
`OffScreenCanvas::clickedItems(const Coord&)`.

## Scrolling

A canvas can be scrolled in one of two ways.  It can be connected to
`GtkScrollBar`s or other widgets elsewhere in the GUI, and it can respond
to `scroll` events generated within the `GtkLayout`.

To connect to scroll bars, call `scrollbar.set_adjustment(adj)` (in
Python) or `gtk_range_set_adjustment(scrollbar, adj)` (in C++),
where `adj` is the `GtkAdjustment` returned by
`GUICanvasBase::getHAdjustment()` or `GUICanvasBase::getVAdjustment()`.

If the `GtkLayout` receives a scroll event, the mousehandler is called
with `event` set to `scroll`.  The `x` and `y` values are the changes
in position, and can be used to modify the adjustments of the scroll
bars:
```python
def mouseCB(eventtype, x, y, button, shift, ctrl, data):
	if eventtype == "scroll":
		sx = horizontalScrollBar.get_adjustment().get_value()
		horizontalScrollBar.get_adjustment().set_value(sx + x)
		...
```


## Details of the OOFCanvas Classes

This section contains detailed information about all of the externally
visible classes in OOFCanvas, starting with the utility classes that
are used by the rest of the code.

### Utility Types: Color, Coord, etc.

These classes are defined in the OOFCanvas namespace and are used for
some arguments and return values by the main OOFCanvas methods.

#### `Coord`

`Coord` is a position in user coordinates, the coordinate system in
which `CanvasItems` are defined.

The `Coord` class is defined in C++, but not in Python.  Methods that
return a position to Python simply return a tuple, (x,y).  When an
OOFCanvas function in Python requires a position argument, any type
that can be indexed can be used.  That is, if you have a coordinate
class called `MyCoord`, you can do this:

```python
pt = MyCoord(x, y)
circle = oofcanvas.CanvasCircle(pt, 1.0)
```
as long as `pt[0]` is x and `pt[1]` is y.  When an OOFCanvas function
returns a `Coord`, it's really returning a tuple, so you can do this:

```python
pt = MyCoord( * oofcanvas.someFunctionReturningACoord() )
```

Whenever a C++ function described below returns a `Coord`, assume that
the Python version works as described above.

The `Coord` constructors are

* `Coord()`

	creates a point at the origin.
	
* `Coord(double x, double y)`

	creates a point at (x,y).
	
The components can be accessed via the x and y data members or via
indexing.  `coord.x == coord[0]`.

Basic arithmetic, assignment, and equality operations are supported.

#### `ICoord`

An `ICoord` is a Coord with integer coefficients, used to identify pixels.

#### `Rectangle`

The `Rectangle` class is not the same as the `CanvasRectangle`.
`CanvasRectangle` is a `CanvasItem` that can be displayed. `Rectangle`
is just a region of space.

A `Rectangle` can be constructed in several ways:

* `Rectangle()` creates an empty rectangle at an undefined position.
* `Rectangle(double x0, double y0, double x1, double y1)` creates a
  rectangle with diagonally opposite corners at (x0, y0) and (x1,
  y1).  It doesn't matter which pair of diagonlly opposite corners are
  given. 
* `Rectangle(const Coord &pt0, const Coord &pt1)` does the same, with
  `Coords` instead of `doubles`.

Useful methods are

* `double Rectangle::xmin() const`
* `double Rectangle::ymin() const`
* `double Rectangle::xmax() const`
* `double Rectangle::ymax() const`
* `Rectangle::swallow(const Coord&)` expands the rectangle to include
  the given point.
	  
	  If the rectangle was uninitialized, this initializes it to an
      rectangle of size 0 at the given point.  That is,
	  `Rectangle r; r.swallow(pt);` is the same as `Rectangle r(pt,
      pt);` for some `Coord pt`.

* `Rectangle::swallow(const Rectangle&)` expands the rectangle include
  the given `Rectangle`.

#### `Color`

Colors are stored as RGBA values, which are doubles between 0 and 1.

C++ Constructors:

* `Color()`

	Initializes to black.

* `Color(double r, double g, double b)`

	Alpha is 1 (opaque).
	
* `Color(double r, double g, double b, double a)`

The only Python constructor is

* `Color(r, g, b)`

To change the opacity of a Python color, use

* `Color Color::opacity(alpha)`

which returns a new `Color` with the given opacity.

Predefined constants are defined for `black`, `white`, `red`, `green`,
`blue`, `gray`, `yellow`, `magenta`, and `cyan`.


### OffScreenCanvas

`OffScreenCanvas` is the base class for the other Canvas classes.  As
the name implies, it can't be displayed on the screen, but it can be
drawn to and the resulting image can be saved to a file.

The constructor is

* `OffScreenCanvas(double ppu)`

	`ppu` is the pixels per unit that determines the conversion
    between user and pixel coordinates.  This is just an initial
    value.  It can be changed later by zooming, but some initial value
    is required.
	
#### Layer manipulation methods in `OffScreenCanvas`

* `CanvasLayer* OffScreenCanvas::newLayer(const std::string& name)`

	creates a new `CanvasLayer` with the given name.  The name is just
    for convenience and debugging.   All layers should be created with
    this method.
	
* `void OffScreenCanvas::deleteLayer(CanvasLayer *layer)`

	deletes a canvas layer from the Canvas and destroys it.  Do not
    simply delete a layer with `delete layer;`
	
* `void OffScreenCanvas::clear()`

	deletes all layers.
	
* `CanvasLayer* OffScreenCanvas::getLayer(int)` const

	gets a particular layer from the stack.
	
* `Canvaslayer* OffScreenCanvas::getLayer(const std::string &name)
  const`
  
	  gets a layer by name.  The Python equivalent is
      `OffScreenCanvas.getLayerByName(name)`. 
	  
* `std::size_t OffScreenCanvas::nLayers() const`

	returns the total number of layers.
	
* `std::size_t OffScreenCanvas::nVisibleItems() const`

	returns the total number of visible items drawn on all layers.
	
* `void OffScreenCanvas::raiseLayer(int n, int howfar)`

	raises layer `n` by `howfar` places in the layer list.  A higher
    layer may hide the contents of a lower layer.
	
* `void OffScreenCanvas::lowerLayer(int n, int howfar)`

	lowers layer `n` by `howfar` places in the layer list.
	
* `void OffScreenCanvas::raiseLayerToTop(int n)`

	moves layer `n` to the top of the layer list.
	
* `void OffScreenCanvas::lowerLayerToBottom(int n)`

	moves layer `n` to the bottom of the layer list.
	
* `void OffScreenCanvas::reorderLayers(const
  std::vector<CanvasLayer*>* layerlist)`
  
  puts the layers in the order given in `layerlist`.  The list
  must contain all of the layers currently in the Canvas and no
  more. In Python the argument is a list `[]` of layers.
  
#### Output methods in `OffScreenCanvas`

* `bool OffScreenCanvas::saveAsPDF(const std::string& filename, int maxpix, bool bg)`

	saves the entire contents of the Canvas to a pdf file with the
    given name. 
	
	* Although the output should be independent of the pixel
      resolution, it's still necessary to pretend that there is a
      pixel size so that OOFCanvas can compute line thicknesses and
      other quantities that might be specified in pixel units.
      `maxpix` is the number of pixels to assume in the largest
      dimension of the image.
	  
	* If `bg` is true the background will be drawn.  Otherwise it will
      be left blank.
	  
	* The return value is true if something was drawn successfully.
	
* `bool OffScreenCanvas::saveAsPNG(...)`

	is the same as `saveAsPDF(...)` but writes a PNG file.
	  
* `bool OffScreenCanvas::saveRegionAsPDF(const std::string& filename,
  int maxpix, bool bg, 
  const Coord& pt0, const Coord& pt1)`
  
	  saves the rectangle defined by `pt0` and `pt1` to the given
      file.  `maxpix` and `bg` are the same as in `saveAsPDF`.  In the
      Python version, `pt0[0]` is the x coordinate of a corner, and
      `pt0[1]` is the y coordinate.
	  
* `bool OffScreenCanvas::saveRegionAsPNG(...)`

	is the same as `saveRegionAsPDF(...)` but writes a PNG file.
  
	
#### Miscellaneous methods in `OffScreenCanvas`

* `double OffScreenCanvas::getPixelsPerUnit() const`

	returns the current scale factor.
	
* `Coord OffScreenCanvas::pixel2user(const ICoord&) const`

	converts a pixel coordinate to a user coordinate.  The Python
    equivalent is `OffScreenCanvas.pixel2user(x,y)`, which returns a
    2-tuple. 
	
* `void OffScreenCanvas::setAntialias(bool)`

	turns anti-aliasing on and off.  The default value depends on your
    device.
	
* `void OffScreenCanvas::setMargin(double)`

	sets the size of the margin around the items on the canvas.  The
    size of the canvas is `1+margin` times the width and height of the
    bounding box of its contents.  The default value is 0.0.
	
* `bool OffScreenCanvas::empty() const`

	has anything been drawn?
	
* `OffScreenCanvas::setBackgroundColor(const Color&)`

	sets the color of the parts of the canvas where nothing has been
    drawn.
	
* `std::vector<CanvasItem*> OffScreenCanvas::clickedItems(const Coord&)`
  
	  returns a list of the `CanvasItems` at the given point, if the
      items are in clickable `CanvasLayer`. 
	  
* `std::vector<CanvasItem*> OffScreenCanvas::allItems() const`

	returns a list all `CanvasItems` on the Canvas, in all
    `CanvasLayers`.
	

### GUICanvasBase

`GUICanvasBase` is an intermediate base class, derived from
`OffScreenCanvas`.  It's the base class for `Canvas` and
`PythonCanvas`, which are the classes that do screen display from C++
and Python.

Methods defined in the base class include:

* `void GUICanvasBase::show()`

	calls `gtk_widget_show` on the Canvas's `GtkLayout`.
	
* `void GUICanvasBase::draw()`
	
	instructs the Canvas to draw all of its `CanvasItems`.

* `int GUICanvasBase::widgetWidth() const`

	returns the width of the space allocated in the GUI for the
    `GtkLayout`.
	
* `int GUICanvasBase::widgetHeight() const`

	returns the height of the space allocated in the GUI for the
    `GtkLayout`.

* `void GUICanvasBase::zoom(double factor)`

	zooms the canvas by the specified factor, keeping the center point
    fixed.
	
* `void GUICanvasBase::zoomAbout(const Coord& fixedpt, double factor)`

	zooms the canvas by the specified factor, keeping the given point
    fixed.  The point is specified in user coordinates.
	
* `void GUICanvasBase::zoomToFill()`

	zooms the canvas so that all `CanvasItems` are visible and as
    large as possible.
	
* `void GUICanvasBase::center()`

	scrolls the canvas so that the center of bounding box of all
    `CanvasItems` is centered on the Canvas, without zooming.
	
* `Rectangle GUICanvasBase::visibleRegion() const`

	returns a `Rectangle` giving the user space coordinates of the
    visible part of the Canvas.
	
* `GtkAdjustment* GUICanvasBase::getHAdjustment() const`

	returns the `GtkAdjustment` that controls horizontal position of
    the canvas.  Connecting this object to a `GtkScrollBar` allows the
    canvas to be scrolled by the user.
	
* `GtkAdjustment* GUICanvasBase::getVAdjustment() const`

	is the same, for the vertical position of the canvas.
	
* `void GUICanvasBase::removeMouseCallback()`	

	removes the mouse callback function.  See below for assigning a
    mouse callback function.
	
* `void GUICanvasBase::allowMotionEvents(MotionAllowed ma)`

	tells the canvas how to respond when the mouse moves, if a mouse
    callback function is installed.  The values of `ma` are
	
	* `MOTION_NEVER`: don't call the callback when the mouse moves.
	* `MOTION_ALWAYS`: call the callback whenever the mouse moves.
	* `MOTION_MOUSEDOWN`: call the callback when the mouse moves only
      if a mouse button is pressed.

	In C++, these values are members of the `MotionAllowed` enum.  In
	Python, they're constants defined in the OOFCanvas namespace.  The
	default value is `MOTION_NEVER`.
	  
* `void GUICanvasBase::setRubberBand(RubberBand*)`

	tells the canvas to start using the `RubberBand` object for
    displaying mouse motions.  See `RubberBand` for details.
	
* `void GUICanvasBase::removeRubberBand()`

	tells the canvas to stop using the rubberband.

### Canvas (C++)

The `Canvas` class is derived from `GUICanvasBase` and is only
available in C++.  A C++ class called `PythonCanvas` is also derived
from `GUICanvasBase`, and is described in the next section.  That
class is accessible from Python under the name `Canvas`, so in effect
there is a `Canvas` class available in both languages, with only
slight differences.

This section describes the `Canvas` class in C++.

The constructor is

```C++
Canvas::Canvas(double ppu)
```

The argument is the initial pixels per unit.

Most of the `Canvas` methods are defined in `GUICanvasBase` or
`OffScreenCanvas`.  The new ones are:

* `GtkWidget* Canvas::gtk() const`

	returns the `GtkLayout` that the `Canvas` is built on.  This
    object is created by the `Canvas` constructor and should be placed
    in the GUI using the usual Gtk operations.

* `void Canvas::setMouseCallback(MouseCallback, void *data)`

	assigns a mouse click callback function, which will be called when
    the mouse button is pressed or released, the mouse is moved, or
    the scroll wheel is scrolled.  To limit the proliferation of
    motion events, see the `GUICanvasBase::BaseallowMotionEvents`
    function.
	
	The signature of the callback function is
	
		```C++
		typedef void (*MouseCallback)(const std::string &event, 
	                              const Coord &position,
								  int button,
								  bool shift, bool ctrl,
								  void *data);
		```
	
	The following arguments are passed to the callback:
	
	* `const std:string& eventtype`
	
		The types are "down" (button was pressed), "up" (button was
        released), "move" (mouse was moved), and "scroll" (scroll
        wheel was turned).
		
	* `const Coord& position`
	
		The position of the mouse event, in user coordinates.
		
	* `int button`
	  
		  Which mouse button was used.
		  
	* `bool shift`
	
		Whether or not the shift key was pressed.
	
	* `bool ctrl`
	
		Whether or not the control key was pressed.
		
	* `void *data`
	
		The data pointer that was passed to `setMouseCallback`.
		
* `void Canvas::setResizeCallback(ResizeCallback, void *data)`

	specifies a function to call when the canvas size changes.  The
    function must take a single `void*` argument, and return
    `void`. When called, the given `data` is passed.
	
### Canvas (Python)

This is the `Canvas` class that is exported to Python.  See the
comments at the of the C++ `Canvas` discussion, above.

The Python `Canvas` creates a `GtkLayout` using Gtk's Python
interface.  The Gtk widget can be accessed directly via
'Canvas.layout`.

The constructor is

```python
Canvas(width, height, ppu, **kwargs)
```

where `width` and `height` are the desired size of the `GtkLayout`, in
pixels. `ppu` is the initial pixels per unit value.  Any additional
keyword arguments in `kwargs` are passed to the `GtkLayout`
constructor.

As with the C++ `Canvas`, most of the functions are defined in the
base class.  They are all available in Python.  New methods are

* `Canvas.destroy()`

	destroys the `Canvas.
	
* `Canvas.setMouseCallback(callback, data)`

	installs a mouse callback function.  This is identical to the
    callback function in the C++ version, except 
	* It's a Python function, not a C++ function.
	* The `position` argument is a tuple, not a `Coord`.
	* The `data` is a Python object, not a `void*`.
	
* `Canvas.setResizeCallback(callback, data)`

	Again, this is just like the C++ version, except the `callback`
    function is a Python function and `data` is a Python object.
	
### CanvasLayer

`CanvasLayers` hold sets of `CanvasItems`, which are the things that
are drawn on the Canvas. Layers may be raised, lowered, shown, and
hidden.

Layers should only be created by a `Canvas` (or `OffScreenCanvas`),
using its `newLayer()` method.

`CanvasLayer` methods include:

* `void CanvasLayer::clear()`

	removes all objects from the layer and makes it transparent.
	
* `void CanvasLayer::clear(const Color&)`

	removes all objects from the layer and fills it with the given
    `Color`.
	
* `void CanvasLayer::addItem(CanvasItem*)`

	adds the given item to the layer.  The layer owns the item.  After
    it's been added to the layer it should not be deleted except by
    clearing or destroying the layer.
	
* `void CanvasLayer::removeAllItems()`

* `bool CanvasLayer::empty() const`

	returns true if the layer contains no `CanvasItems`.

* `void CanvasLayer::destroy()`

	destroys the layer and removes it from the Canvas.
	
* `void CanvasLayer::show()`
  
	  makes the layer visible if it was previously hidden.  New layer
      are initially visible.
	  
* `void CanvasLayer::hide()`

	make the layer invisible.
	
* `void CanvasLayer::setClickable(bool)`

	If the argument is true, objects in the layer can be listed by
    `OffScreenCanvas::clickedItems()`.
	
* `void CanvasLayer::setOpacity(double)`

	sets the opacity with which the layer will be copied to the
    Canvas. 0.0 is fully transparent and 1.0 is fully opaque.
	
* `void CanvasLayer::raiseBy(int howfar) const`

	raises the layer in the Canvas by the given amount. This is the
    same as `OffScreenCanvas::raiseLayer(int n, int howfar)` except that you
    don't need to know the layer number `n`.
	
* `void CanvasLayer::lowerBy(int howfar) const`

	is the same as `raiseBy`, but in the other direction.
	
* `void CanvasLayer::raiseToTop() const`

	is the same as `OffScreenCanvas::raiseLayerToTop(int n)`.
	
* `void CanvasLayer::lowerToBottom() const`

	is the same as `OffScreenCanvas::lowerLayerToBottom(int n)`.
	
* `void CanvasLayer::writeToPNG(const std::string& filename)`
  
	  saves the contents of the layer to a PNG file.

### CanvasItem

`CanvasItem` is the base class for everything that can be drawn on the
canvas.

#### Abstract CanvasItem Subclasses

##### `CanvasShape`

This is an abstract base class for most other `CanvasItem` classes.
It defines the following methods:

* `void CanvasShape::setLineWidth(double)`
* `void CanvasShape::setLineWidthInPixels(double)`

	`setLineWidth` sets in the width in user
    units. `setLineWidthInPixels` sets it in pixel units.

* `void CanvasShape::setLineColor(const Color&)`

	See `Color`, below.

* `void CanvasShape::setLineJoin(Cairo::LineJoin)`

	In C++, the argument is a member of the [`Cairo::LineJoin`]
	(https://www.cairographics.org/documentation/cairomm/reference/classCairo_1_1Context.html)
	class.  In Python, it's `lineJoinMiter`, `1ineJoinRound`, or
	`lineJoinBevel`, which are defined in the OOFCanvas namespace.

* `void CanvasShape::setLineCap(Cairo::LineCap)`

	In C++, the argument is a member of the [`Cairo::LineCap`]
	(https://www.cairographics.org/documentation/cairomm/reference/classCairo_1_1Context.html)
	class.  In Python, it's `lineCapButt`, `lineCapRound`, or
	`lineCapSquare`, which are defined in the OOFCanvas namespace.

* `void CanvasShape::setDash(const std::vector<double>&, int offset)`

	The vector contains a pattern of dash lengths, which are in
	user units.  The pattern repeats as necessary.  `offset`
	indicates where the pattern starts.
	
* `void CanvasShape::setDashInPixels(const std::vector<double>&, int offset)`

	The same as the above `setDash`, but the dash lengths are
    interpreted in pixel units.

* `void CanvasShape::setDash(double)`

	Use a single dash length, which is in user units.

* `void CanvasShape::setDashInPixels(double)`

	The same as `setDash(double)`, but the dash lengths are in pixel
    units.


* `void CanvasShape::setDashColor(const Color&)`

	Fill the spaces between dashes with the given color,
	instead of leaving them blank.
	
* `void CanvasShape::unsetDashes()`

	Turn off dashes. Draw solid lines.
			
##### `CanvasFillableShape`

This abstract class in derived from `CanvasShape` and is used for
closed shapes that can be filled with a color.  It provides one
method:

* `void CanvasFillableShape::setFillColor(const Color&)`

	Fill the shape with the given color.

#### Concrete CanvasItem Subclasses

##### `CanvasArrowhead`

An arrowhead can be placed on a `CanvasSegment`.  The
`CanvasArrowhead` class is *not* derived from `CanvasShape`.  Its
constructor is
	
* `CanvasArrowHead(const CanvasSegment *segment, double position, bool reversed)`
		
	`segment` is the `CanvasSegment` that the arrowhead will be drawn
	on. `
	
	`position` ranges from 0.0 to 1.0, and determines where the tip of
	the arrow will appear on the segment.  A value of 0.0 puts the tip
	at the first point of the segment, and a value of 1.0 puts it at
	the second point.  The color of the arrowhead is the same as the
	line color of the `CanvasSegment`.
	
The size of the arrowhead is set by either

* `void CanvasArrowHead::setSize(double width, double length)`

	`width` and `length` are in user units.

or

* `void CanvasArrowHead::setSizeInPixels(double width, double length)`

	`width` and `length` are in pixels.
	
Either `setSize()` or `setSizeInPixels()` *must* be called before an
arrowhead can be drawn.

##### `CanvasCircle`

Derived from `CanvasFillableShape`.  Its constructor is
	
* `CanvasCircle(const Coord &center, double radius)`
	
The coordinates of the center and the radius are in user units.  To
specify the radius in pixels, use [`CanvasDot`](#`CanvasDot`) instead.

##### `CanvasCurve`

A `CanvasCurve` is a set of line segments connected end to end.  It is
derived from `CanvasShape`, but not `CanvasFillableShape`.  It is
specified by listing the sequence of points joined by the segments.
Its constructors are
	
* `CanvasCurve()`

	Create an empty curve, containing no points.  This constructor
	must be used in Python.

* `CanvasCurve(int n)` 

	Create a curve with room reserved for `n` points, but don't
	actually create the points.

* `CanvasCurve(const std::vector<Coord> &points)`

	Create a curve with the given points.

Points can be added to a `CanvasCurve` via

* `void CanvasCurve::addPoint(const Coord&)`

or 

* `void CanvasCurve::addPoints(const std::vector<Coord>*)`

In Python, the argument to `addPoints` is a list of Coord-like (ie,
indexable) objects.

`int CanvasCurve::size()` returns the number of points in the curve.

##### `CanvasDot`

Derived from `CanvasFillableShape`, a `CanvasDot` is a circle with a
fixed size in pixels.  Its line width is also always measured in
pixels.  The constructor is

* `CanvasDot(const Coord &center, double radius)`


##### `CanvasEllipse`

Derived from `CanvasFillableShape`.  The constructor is

* `CanvasEllipse(const Coord &c, const Coord &r, double angle)`

where `c` is the center in user coordinates and the components of `r`
are the radii in user units.  `r[0]` is the radius in the x direction
before rotation.  The rotation angle in degrees is measured
counterclockwise.
	
##### `CanvasImage`

`CanvasImage` can display a PNG file, or if compiled with the
[ImageMagick](https://imagemagick.org/index.php) library, any format
that ImageMagick can read.  To enable ImageMagick, define
`OOFCANVAS_USE_IMAGEMAGICK` when building OOFCanvas.

The constructor creates an empty image:

* `CanvasImage(const Coord &position, const ICooord &npixels)`

where `position` is the position of the lower left corner of the
image in user coordinates.

*Confusion Opportunity!*  There are two kinds of pixels.  There are the
pixels on your computer screen, and there are the pixels in the
`CanvasImage`.  They don't have to be the same size.  A `CanvasImage`
may be displayed at a different scale from its natural size, in which
case one `CanvasImage` pixel will be larger or smaller than one screen
pixel.

Since an empty image isn't very useful, `CanvasImage` includes some
static factory methods for creating `CanvasImage` objects. 

* Create a blank image:

	```C++
	CanvasImage* CanvasImage::newBlankImage(
           const Coord& position,
		   const ICoord& pixelsize,
		   const Color &color);
   ```

	The image is filled with a single color, `color`, so it's not
	really blank.  `position` is the user coordinate of the lower left
	corner of the image. `size` is the size that it will be drawn, in
	user units. `pixelsize` is the size of the image in pixels.

* Read a png file:

	```C+++
	CanvasImage* CanvasImage::newFromPNGfile(
		   const Coord &position,
		   const std::string& filename)
	```

	`position` is the position of the lower left corner of the image
	in user coordinates, and `size` is its displayed size, in user
	units. 
   
* Read any file format that ImageMagick can handle:

	```C++
	CanvasImage* CanvasImage::newFromImageMagickFile(
		   const Coord& position,
		   const std::string& filename)
	```

	`position` is the position of the lower left corner of the image
	in user coordinates, and `size` is its displayed size.

* Create a CanvasImage from ImageMagick data:

	```C++
	CanvasImage* CanvasImage::newFromImageMagick(
		const Coord& position,
		Magick::Image imagedata)
   ```

	Create a `CanvasImage` from image data that has already been read
	by [ImageMagick](https://imagemagick.org/index.php).  The data is
	copied from the ImageMagick structure.


`CanvasImage` provides the following useful methods:

* Set the displayed size of the image, in user coordinates:

	`void CanvasImage::setSize(const Coord&)`
	
	or in pixel (screen) coordinates:
	
	`void CanvasImage::setSizeInPixels(const Coord&)`
	
	Either `setSize` or `setSizeInPixels` *must* be called before an
    image can be displayed.

* Set the style for drawing individual pixels

	`CanvasImage::setDrawIndividualPixels(flag)`

	Cairo draws pixels as small fuzzy blobs, which may or may not be
    what you want, especially if you need to zoom in.  When examining
    data on the image pixel level (not the screen pixel level) it can
    be convenient to draw each pixel as a rectangle.  Call
    `setDrawIndividualPixels(true)` to switch to this mode, or
    `setDrawIndividualPixels(false)` to turn it off.
	
* Examine individual pixels

	`Color CanvasImage::get(const ICoord &) const;`
	
	This returns the color of the pixel at the given point in the image.
	The `ICoord` is the location of the pixel in the *image*, not the
    canvas.  As such, it uses standard image coordinates, with x
    increasing from left to right and y increasing from top to bottom.
	
* Modify individual pixels

	`void CanvasImage::set(const ICoord&, const Color&)`

	The `ICoord` is the location of the pixel in the *image*, not the
    canvas.  As such, it uses standard image coordinates, with x
    increasing from left to right and y increasing from top to bottom.
	
	If you need to make extensive modifications to an image, it's
    better to use some other tools first and then load the modified
    image into the `CanvasImage`.
	
* Set overall opacity

	`void CanvasImage::setOpacity(double alpha)`
	
	This sets the opacity for the entire image, used when it is copied
    to the `Canvas`.  It doesn't actually change any image data.


##### `CanvasPolygon`

A `CanvasPolygon` is a closed `CanvasCurve`, derived from
`CanvasFillableShape`.  It is specified by listing the corners of the
polygon, counterclockwise.  Its constructors are

* `CanvasPolygon()`

	Create an empty polygon, containing no points.  This constructor
    must be used in Python.
	
* `CanvasPolygon(int n)`

	Create a polygon with room for `n` points, but don't actually
    create the points.  Points must be added with `addPoints`.
	
* `CanvasPolygon(const std::vector<Coord>& points)`

	Create a polygon from the given vector of `Coords`.
	
To add points to a polygon, in C++ use either

* `CanvasPolygon::addPoint(double x, double y)`
* `CanvasPolygon::addPoint(const Coord&)`

or

* `CanvasPolygon::addPoints(const std::vector<Coord>*)`

In Python, use

* `CanvasPolygon.addPoint(x, y)`
* `CanvasPolygon.addCoord(pt)`

	where `pt` is some kind of point object, with `pt[0]` being x and
    `pt[1]` being y.

or

* `CanvasPolygon::addPoints(ptlist)`

	where `ptlist` is a list of point objects `pt`, where `pt[0]` is x and
    `pt[1]` is y.

##### `CanvasRectangle`

Derived from `CanvasFillableShape`.  The constructor is 

* `CanvasRectangle(const Coord&, const Coord&)`

where the `Coord`s are the user coordinates of any two opposite
corners of the rectangle.
			
##### `CanvasSegment`

A single line segment, derived from `CanvasShape`.  The
constructor is

* `CanvasSegment(const Coord &point0, const Coord &point1)`

The positions are given in user coordinates.
		
##### `CanvasSegments`

'CanvasSegments` is derived from `CanvasShape` and draws a set of
unconnected line segments all with the same color and width.

The constructors are

* `CanvasSegments()`

	creates an empty object.
	
* `CanvasSegments(int n)`

	allocates space for `n` segments, but doesn't create them.  This
    form is only available in C++.
	
To add segments to the object, use

* `CanvasSegments::addSegment(const Coord &pt0, const Coord &p1)`

	The segment goes from `pt0` to `pt1`.
	
##### `CanvasText`

`CanvasText` displays text at an arbitrary position and orientation.
It is derived from `CanvasItem`.  The text is drawn by the
[Pango](https://pango.gnome.org/) library.

The constructor is

* `CanvasText(const Coord &location, const std::string &text)`

where `location` is the position of the lower left corner of the text, in
user coordinates.

`CanvasText` methods include

* `CanvasText::setFillColor(const Color& color)`

	sets the color of the text.
	
* `CanvasText::setFont(const std::string &fontdesc, bool inPixels)`

	`fontdesc` is a string that will be passed to
    [`pango_font_description_from_string()`]
	(https://docs.gtk.org/Pango/type_func.FontDescription.from_string.html)
    to determine the font.  It includes a font family or families,
    style options, and size (for example, `"Times Bold 0.2"`).  The
    size is interpreted in pixels if `inPixels` is true and in
    user units otherwise. The names of the installed font families
    are returned by the `list_fonts()` function.
	
* `CanvasText::rotate(angle)`

	rotates the text by the given angle, in degrees, about the left
    end of the text's baseline.  Positive angles are counterclockwise.

### RubberBand

Rubberbands are dashed lines drawn on top of the rest of the Canvas to
indicate mouse movements while a mouse button is pressed.  The
rubberband will be drawn while the mouse is down if a mouse callback
calls `GUICanvasBase::setRubberBand(RubberBand*)`.  Drawing will cease
after `GUICanvasBase::removeRubberBand()` is called.

Five subclasses of `RubberBand` are defined:

* `LineRubberBand` is a straight line from the mouse-down position to
  the current position.
  
* `RectangleRubberBand` is rectangle with one corner at the mouse-down
  position and the diagonally opposite corner at the current position.
  
* `CircleRubberBand` is a circle centered on the mouse-down position
  and passing through the current position.
  
* `EllipseRubberBand` is an ellipse that is fit into a rectangle, as
	in `RectangleRubberBand`.
	
* `SpiderRubberBand` is a set of line segments, starting at given
  points and ending at the current mouse position.  The start points
  are specified by calling `SpiderRubberBand::addPoints(list)`, where
  in C++, `list` is a `std::vector<Coord>*`.  In Python, it's a
  iterable collection of objects where `obj[0]` is the x component of
  `obj` and `obj[1]` is its y component.
  
The appearance of the rubberband is controlled by these functions in
the `RubberBand` base class:

* `void RubberBand::setLineWidth(double width)`

	width is the line width in pixel units.
	
* `void RubberBand::setColor(const Color& color)`

	sets the color of the dashed line.
	
* `void RubberBand::setDashLength(double length)`

	sets the length of the dashes in pixels.
	
* `void RubberBand::setDashColor(const Color &color)`

	sets the color of the line *between* the dashes.  If this function
    is not called, the spaces between the dashes are not filled.
	
* `void RubberBand::setDashed(bool)`

	turns the dashes on and off.  Undashed rubberbands drawn with
    solid lines may be hard to see on some backgrounds.  The default
    is to draw dashes.


## Appendix: Adding new CanvasItem subclasses

New `CanvasItem` subclasses can be derived from `CanvasItem`,
`CanvasShape`, or `CanvasFillableShape`.  A `CanvasShape`  is a
`CanvasItem` with predefined methods for setting line drawing
parameters.  A `CanvasFillableShape` is a `CanvasShape` with
predefined methods for setting a fill color.

The derived class constructor must invoke the base class constructor,
passing a `Rectangle` as the argument.  The rectangle is the item's
bounding box: the smallest rectangle in user space that
completely encloses the item.  The sides of the rectangle are aligned
with the x and y axes.  If the bounding box is not known, an
uninitialized rectangle (`Rectangle()`) can be passed.

### `CanvasItem`

A `CanvasItem` must define three virtual methods:

* `void drawItem(Cairo::RefPtr<Cairo::Context> context) const`

	Draw the item to the given `Cairo::Context`, using Cairo
    functions.

* `bool containsPoint(const OffScreenCanvas*, const Coord&) const`

	Return true if the given point (in user coordinates)
    is inside the `CanvasItem`.   If the item isn't selectable by
    clicking, this method can always return false.
	
* `std::string print() const`

	Return a descriptive string.  Used for debugging.
	
In addition, the `CanvasItem` must provide information about its
bounding box in one of two ways, depending on whether or not the
bounding box size is known when the item is first built: 

1. Set `bbox` in the constructor.  `bbox` is a `Rectangle`
   stored in the `CanvasItem` base class.
   
2. Redefine `const Rectangle& findBareBoundingBox() const` in the
   derived class.  This returns the `Rectangle` that the item would
   occupy in user coordinates if the pixel size were zero (i.e, if
   the `ppu` were infinite).
   
   Also, redefine `void pixelExtents(double& left, double& right,
   double& up, double& down) const` in the derived class.  The four
   arguments must be set to the distances, in pixel units, that the
   item extends beyond its bare bounding box. The values will
   generally be nonzero only if the item has components whose size is
   specified in pixels instead of user units. If all sizes are in
   physcial units, then the bare bounding box is the actual bounding
   box, and all pixel extents are zero.  In that case, `pixelExtents`
   does not have to be redefined in the derived class.
   
Any operation that changes an item's size after it's been added to a
`CanvasLayer` should call 'void CanvasItem::modified()`.

### `CanvasShape`

`CanvasShape` is an intermediate base class for `CanvasItems` that
draw lines.  All of the lines must have the same color, width, and
other characteristics.  `CanvasShape` does not store the lines -- it
only provides the machinery for setting their style parameters.  The
subclass's `drawItem` method should set up a Cairo path and then call
`CanvasShape::stroke(context)` to draw it, where `context` is the
`CairoContext` that was passsed to `drawItem()`.

### `CanvasFillableShape`

`CanvasFillableShape` is another intermediate base class for
`CanvasItems`.  It extends `CanvasShape` by adding a method for
setting a fill color.  When `CanvasFillableShape::stroke(context)` is
called, it draws lines and fill shapes with the current settings.

## Appendix: Internal Order of Operations

It shouldn't be necessary to understand this section in order to use
OOFCanvas.  It's here to help development.

Each `CanvasLayer` contains a `Cairo::ImageSurface` which contains a
bitmap of what's been drawn in the layer, a `Cairo::Context` which
controls drawing to surface, and a `Rectangle` which is the bounding box
(in user coordinates) of all of the layer's `CanvasItems`. 

When a `CanvasItem` is added to a `CanvasLayer`, the layer is marked
"dirty" and the item is stored in the layer.  No drawing is done at
this point.

When all items have been added to the layers, calling
`GUICanvasBase::draw()` generates a draw event on the `GtkLayout`.  This
causes `GUICanvasBase::drawHandler()` to be called.  The argument to
drawHandler is the `Cairo::Context` for drawing to the `GtkLayout`'s
`Cairo::Surface`. 

`GUICanvasBase::drawHandler()` begins by computing the horizontal and
vertical offsets that will be used to keep the image centered in
the gtk window (if the image is smaller than the window) or at the
position determined by the scroll bars (if the image is larger than
the window).

Next, drawHandler calls `Canvas::setTransform()`, which computes the
matrix that converts from user coordinates to bitmap coordinates
within the layer, given the ppu.  The `GtkLayout` is resized if
necessary so that it is large enough to accomodate the bounding boxes
of all of the layers, plus an optional margin (set by
`OffScreenCanvas::setMargin()`).  Note that a layer's bounding box, in
user units, can depend on the ppu if the layer contains items with
sizes given in pixels.

What happens next depends on whether or not a rubberband is being
drawn.  If there is no rubberband, `GUICanvasBase::drawHandler` draws the
background color and then, for each layer from bottom to top, tells
the layer to draw all of its `CanvasItems`s to its own `Cairo::ImageSurface`
(`CanvasLayer::render()`), and copies the layer's surface to the
`GtkLayout`'s surface (`CanvasLayer::copyToCanvas()`) at the position
given by the scroll bars.  (`CanvasLayer::render()` only redraws its
items if any have changed since the last time they were drawn.)

If there is an active rubberband, on the first call to `drawHandler`
after the mouse button was  pressed all of the `CanvasLayer`s other
than the rubberband's layer are rendered to a separate
`Cairo::ImageSurface` called the `nonRubberBandBuffer`.  Then this
buffer is copied to the `GtkLayout` and the rubberband is drawn on top
of it.  On subsequent calls to `drawHandler`, the
`nonRubberBandBuffer` is copied and the rubberband is drawn, but the
`nonRubberBandBuffer` is not rebuilt unless the layers have changed.






					 





